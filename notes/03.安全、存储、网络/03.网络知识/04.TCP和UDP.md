---
title: "TCP和UDP"
date: "2020-01-30"
permalink: "notes/2020-01-30-TCP-and-UDP"
---

⚡<strong>「内容速览」</strong>⚡

- TCP
- UDP
- TCP和UDP的区别
- 三次握手
- 四次挥手
- 为什么需要三次握手
- 为什么需要四次挥手
- 为什么需要等待2MSL
- 如果TCP连接建立成功，客户端故障了怎么办？

### TCP
传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

面向连接指在收发数据之前，TCP会进行三次握手，断开连接时，TCP会进行四次挥手。

可靠指TCP协议通过一系列方式，例如校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制来保证数据传输可靠性。

- 校验和

发送方在发送数据之前计算检验和，并进行校验和的填充。接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。如不一致数据一定传输有误。

- 序列号

TCP传输时将每个字节的数据都进行了编号，这就是序列号。 

- 确认应答

TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

- 超时重传

在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果没有发送方没有接受到响应的ACK报文原因可能有两点：

1. 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
2. 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。

TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。

- 连接管理

连接管理就是三次握手与四次挥手的过程，是保证可靠性的前提。

- 流量控制

TCP根据接收端对数据的处理能力，决定发送端的发送速度，避免因发送数据过快导致丢包的一系列连锁反应，这个机制就是流量控制。

- 拥塞控制

TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。

详细内容：[TCP协议如何保证可靠性](https://blog.csdn.net/wodewutai17quiet/article/details/82252454)

通过TCP来传输数据有以下特点：

- 数据无差错，不丢失，不充分，按序到达。
- TCP报文头里面的序号能够使TCP数据按序到达。
- 报文头里面的确认序号能够保证不丢包，累计确认和超时重传。
- TCP拥有流量控制及拥塞机制。

TCP的顺序问题，丢包问题，流量控制都是通过滑动窗口；拥塞控制通过拥塞窗口


TCP数据包：

![cache](~@images/other/TCP.png)

- 源端口号和目标端口号是不可少的

- 包的序号是为了解决乱序的问题。不编好号怎么确认哪个应该先来，哪个应该后到呢。

- 确认序号指发出去的包应该有确认，要不然我怎么知道对方有没有收到呢？如果没有收到就应该重新发送，直到送达。这个可以解决不丢包的问题。

- 状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。

- 窗口大小。TCP 要做流量控制，通信双方各声明一个窗口，标识自己当前能够的处理能力。

### UDP
用户数据报协议（User Datagram Protocol）是一种无连接的传输层通信协议，不需要建立连接就可以发送封装的 IP 数据包的方法。

UDP的特点有：

1. UDP是一个非连接的协议。

传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上

在发送端：UDP传送数据的速度受应用程序生成数据的速度，计算机的能力，和传输带宽的限制的影响。

在接收端：UDP把每个消息段放在队列中，应用程序每次从队列中读取一个消息段。

2. 不维护连接状态，支持同时向多个客户端传输相同的消息

由于传输数据不建立连接，因此不需要维护连接状态，包括收发状态等；因此一台服务器可同时向多个客户机传输相同的消息。

3. UDP尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。

4. 信息包的报头很短，只有8个字节，相对于TCP的20个字节信息包的额外开销较小。

5. 吞吐量不受拥挤控制算法的调节，只受应用数据的速率，传输带宽，源端和终端主机性能的限制。

6. 面向报文的，不对应用程序提交的报文信息拆分或者合并。

发送端的UDP对应用程序发下来的报文，添加首部后，就向下交付给IP层，既不拆分也不合并，而是保留这些报文的边界。因为应用程序需要选择合适的报文大小。UDP将大多数的控制权交由上层去解决。

UDP数据包：

![cache](~@images/other/UDP.png)

- 源端口号 16位

- 目的端口号 16位

- 长度 16位

- 校验和 16位


### TCP和UDP的区别

|  TCP   | UDP  |
|  :----:   | :----:  | 
| 面向连接（ 三次握手连接过程）  | 面向无连接（因为面向无连接，所以UDP适合消息的多点发布，即从单个点向多个点传送信息）| 
| 可靠性（利用握手机制、序列号、确认应答和重传机制）  | 不可靠（UDP可能会丢失，不知道到底有没有被接收） |
| 有序性（TCP利用序列号保证了消息报的顺序交付，到达可能无序，但TCP最终会排序）  | UDP无序 |
| TCP速度比较慢（因为要创建连接，保证消息的可靠性和有序性）  | UDP比较快（UDP适合对速度比较敏感的应用，比如：在线视频媒体，电视广播，多人在线游戏。） |
| TCP重量级（体现在源数据的头和大小，TCP20个字节）  | UDP轻量级（UDP8个字节） |


### 三次握手

![cache](~@images/other/three-handshake.png)

第一次握手：客户端向服务器发送同步序列号SYN=1的报文，告诉服务器我想要和你通信，同时客户端进入SYN-SENT（同步已发送状态），等待服务器确认。

第二次握手：服务器收到syn报文，如果同意连接, 则发送一个带有确认号（ACK）和同步序列号（SYN）标志位的报文给客户端，告诉客户端收到请求，可以传输数据，同时服务器进入了SYN-RCVD（同步已收到）状态。

第三次握手：客户端收到服务器的SYN+ACK报文，向服务器发送确认报文ACK，告诉服务器我已收到回复，我现在要开始传输实际数据了。此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

### 四次挥手

![cache](~@images/other/four-wave.png)

第一次：客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN控制位值为1，表示希望断开连接。此时，客户端进入FIN-WAIT-1（终止等待1）状态。

第二次：服务器收到连接释放报文，发出确认报文，ACK=1，然后服务器通知高层的应用进程，客户端向服务器的方向就释放了，服务端就进入了CLOSE-WAIT（关闭等待）状态，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

第三次：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1。服务器就进入了LAST-ACK（最后确认）状态。

第四次：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时客户端TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态；服务器只要收到了客户端发出的确认，立即进入CLOSED状态。


### 为什么需要三次握手

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。


### 为什么需要四次挥手
关闭连接时，服务器收到客户端的FIN报文时，仅仅表示客户端不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给客户端了，所以服务端可以立即关闭，也可以发送一些数据给客户端后，再发送FIN报文给客户端来表示同意现在关闭连接，因此，服务端ACK和FIN一般都会分开发送，先告诉客户端收到释放报文，等服务端数据发送完成后，再向客户端发送服务端连接释放报文。

### 为什么需要等待2MSL
保证客户端发送的最后一个ACK报文能够到达服务器，网络有可能是不可靠的，客户端发送出最后的ACK回复可能会丢失，此时服务器会认为发送的连接释放报文客户端没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

### 如果TCP连接建立成功，客户端故障了怎么办？
TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若发送10个探测报文仍然没响应，服务器就认为客户端出了故障，接着就关闭连接。


参考连接：

[TCP 详解](https://blog.csdn.net/sinat_36629696/article/details/80740678)

[重学网络系列之（TCP）](https://blog.csdn.net/qq_42820805/article/details/112856177)

[TCP与UDP区别](https://www.jianshu.com/p/6f29d49c1b04)

