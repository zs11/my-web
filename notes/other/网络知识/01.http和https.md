---
title: "http和https"
date: "2020-01-30"
permalink: "notes/2020-01-30-http-https"
---

⚡<strong>「内容速览」</strong>⚡

- http
- http状态码
- https
- CA证书的验证

### http
HTTP全称Hypertext Transfer Protocol，即超文本传输协议，因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准，http承载于TCP协议之上的一个应用层协议，主要由请求和响应构成。

- http请求报文

HTTP 请求报文请求行（request line）、请求头（header）和请求体3个部分组成。
![vue-reactivity](~@images/other/http_request.png)

请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。

请求头部由关键字/值对组成请求头部通知服务器有关于客户端请求的信息。

请求体就是请求的数据。

- http响应报文

HTTP响应同样由3个部分构成，分别是响应行、响应头、响应正文。
![vue-reactivity](~@images/other/http_response.png)

响应行包括报文协议及版本、状态码和状态描述。

响应头和请求头一样由多个属性组成

响应正文也就响应体，其中包括我们想要的数据。

### http状态码

HTTP状态码的英文为HTTP Status Code。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

- 1xx：指示信息–表示请求已接收，继续处理。
- 2xx：成功–表示请求已被成功接收、理解、接受。
- 3xx：重定向–要完成请求必须进行更进一步的操作。
- 4xx：客户端错误–请求有语法错误或请求无法实现。
- 5xx：服务器端错误–服务器未能实现合法的请求。

详细状态对应作用：https://www.runoob.com/http/http-status-codes.html


### https

- https出现的目的：
因为HTTP协议以明文形式传输数据，所以就会面临3个问题：

1. 窃听风险：中间人可以对通信进行窃听。

2. 篡改风险：中间人可以修改通信内容。

3. 冒充风险：中间人可以冒充他人身份参与通信。

为了保证通信的隐私和信息安全就有了https，https本质上就是在http的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），通过TLS/SSL来建立安全通信信道，加密数据包，身份认证，保护交换数据的隐私与完整性。

Https中涉及到对称加密和非对称加密：

- 对称加密，就是加密解密同时运用同一个密钥。

- 非对称加密加密指的是，加密和解密用的并不是同一把钥匙。

SSL握手的过程：

1. 客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。

2. 服务端向客户端发送 Server Hello 消息，这个消息包括从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。

3. 紧接着服务端还会自己的证书下发给客户端，让客户端验证自己的身份。证书中包括证书颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容

4. 客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key，然后发送给服务端。

5. 服务端再用自己的私钥解密得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法利用这个随机数生成一份秘钥，后续通信使用这个秘钥进行对称加密。使用三个随机数的原因是多个随机数种子来生成秘钥不容易被暴力破解出。

6. 这时候SSL握手还没结束，客户端和服务器还需要验证下刚刚协商的出来密码是否能正常解密。客户端将前面的握手消息通过hash生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。

7. 服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。

8. 同样服务端也会将握手过程的消息生成通过hash摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。

9. 到这里，双方已安全地协商出了同一份秘钥，SSL建立完成，应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。

### CA证书的验证

CA证书包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。

验证过程：

1. 当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。

2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。
